# Debug logging was added by Github Copilot
from flask import (
    Flask,
    redirect,
    url_for,
    render_template,
    g,
    make_response,
    request,
    jsonify,
    session,
    send_file
)
import shutil
import jinja2
import os
import sqlite3
import json
import datetime, time
import secrets
import hashlib
import hmac
from dotenv import load_dotenv
from flask_dance.contrib.github import make_github_blueprint, github
import requests
from requests.auth import HTTPBasicAuth

load_dotenv()
app = Flask(__name__)

# ensure datadir exists

if not os.path.exists(
    os.path.join(os.path.dirname(os.path.realpath(__file__)), os.getenv("dataDir"))
):
    print("Setting up datadir")
    shutil.copytree(
        os.path.join(os.path.dirname(os.path.realpath(__file__)), "datadir-template"),
        os.path.join(os.path.dirname(os.path.realpath(__file__)), os.getenv("dataDir")),
    )

# fix reverse proxies
from werkzeug.middleware.proxy_fix import ProxyFix

app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

app.config.from_mapping({"DEBUG": True})
# done by chatGPT
def revoke_github_token(user_token):
    client_id = os.getenv("githubClientID")
    client_secret = os.getenv("githubClientSecret")

    url = f"https://api.github.com/applications/{client_id}/grant"
    headers = {
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
    }
    data = {"access_token": user_token}

    resp = requests.delete(
        url, auth=HTTPBasicAuth(client_id, client_secret), headers=headers, json=data
    )
    return resp.status_code, resp.text


# generated by copilot
def generate_deletion_token(user_id):
    """Generate a secure, time-limited token for account deletion"""
    timestamp = str(int(time.time()))
    secret_key = os.getenv("flaskDanceSecret")  # Use your existing secret

    # Create payload: user_id + timestamp
    payload = f"{user_id}:{timestamp}"

    # Create HMAC signature
    signature = hmac.new(
        secret_key.encode(), payload.encode(), hashlib.sha256
    ).hexdigest()

    # Combine payload and signature
    token = f"{payload}:{signature}"
    return token


def validate_deletion_token(token, user_id, max_age=300):  # 5 minutes
    """Validate the deletion token"""
    try:
        parts = token.split(":")
        if len(parts) != 3:
            return False

        token_user_id, timestamp, signature = parts

        # Check if user ID matches
        if int(token_user_id) != user_id:
            return False

        # Check if token is not expired
        token_time = int(timestamp)
        if time.time() - token_time > max_age:
            return False

        # Verify signature
        secret_key = os.getenv("flaskDanceSecret")
        expected_payload = f"{token_user_id}:{timestamp}"
        expected_signature = hmac.new(
            secret_key.encode(), expected_payload.encode(), hashlib.sha256
        ).hexdigest()

        return hmac.compare_digest(signature, expected_signature)

    except (ValueError, TypeError):
        return False


def get_db():
    if "db" not in g:
        if "github_id" not in session:
            return None
        user_db_path = os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            "userdata",
            f"user_{session['github_id']}.sqlite",
        )
        template_path = os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            f"user_template.sqlite",
        )
        if not os.path.exists(user_db_path):
            if os.path.exists(template_path):
                shutil.copy2(template_path, user_db_path)
            else:
                raise FileNotFoundError("Template file missing!")
        g.db = sqlite3.connect(user_db_path)
        g.db.row_factory = sqlite3.Row
    return g.db


@app.teardown_appcontext
def close_db(error):
    db = g.pop("db", None)
    if db is not None:
        db.close()


app.secret_key = os.getenv("flaskDanceSecret")
blueprint = make_github_blueprint(
    client_id=os.getenv("githubClientID"),
    client_secret=os.getenv("githubClientSecret"),
)
# custom filter (was written by GPT.)
@app.template_filter()
def timestamp_to_time(value, thing):
    if isinstance(value, jinja2.runtime.Undefined) or value is None:
        return None
    return datetime.datetime.fromtimestamp(value).strftime(thing)


app.register_blueprint(blueprint, url_prefix="/login")


def generateUpdates(state):
    db = get_db()
    cur = db.execute(
        "SELECT COALESCE(SUM(transactionCost), 0) AS total_value FROM transactions;"
    )
    totalValue = cur.fetchone()['total_value']
    cur = db.execute("SELECT * FROM tasks")
    res = cur.fetchall()
    data = {
        "state": state,
        "pageUpdates": [
            {"action": "innerText",
             "selector": "#coinsBalanceValue",
             "value": totalValue},
            {
                "action": "innerHTMLupdate",
                "selector": "ul.tasksList",
                "value":render_template("tasksCard.html", tasks=res)
            }
        ]
    }
    return data


@app.route("/logout", methods=["GET"])
def logout():
    session.clear()
    res = make_response("Logged Out.")
    res.set_cookie("session", "", max_age=0)
    return res


@app.route("/", methods=["GET"])
def index():
    if not github.authorized:
        return redirect(url_for("github.login"))
    if "github_id" not in session:
        resp = github.get("/user")
        assert resp.ok
        user_info = resp.json()
        session["github_id"] = user_info["id"]
        session["github_login"] = user_info["login"]
    db = get_db()
    # this be the old way
    # cur = db.execute(
    #     "SELECT userCoins FROM users WHERE userid = ?", (session["github_id"],)
    # )
    # data = cur.fetchall()
    usercoins = 0
    cur = db.execute(
        "SELECT COALESCE(SUM(transactionCost), 0) AS total_value FROM transactions;"
    )
    res = cur.fetchone()
    username = session["github_login"]
    cur = db.execute("SELECT * FROM tasks")
    return render_template(
        "app.html",
        username=username,
        usercoins=res["total_value"] + usercoins,
        tasks=cur.fetchall(),
    )


@app.route("/api", methods=["GET"])
def notforyou():
    return "no"


@app.route("/api/updateTaskState", methods=["POST"])
def uts():
    state = "1$it probably worked idk"
    selector = "ul.tasksList"
    if "id" in request.form and "state" in request.form:
        # Debug logging
        print(f"DEBUG: Received id={request.form['id']}, state={request.form['state']}")
        if not github.authorized:
            return redirect(url_for("github.login"))
        db = get_db()
        cur = db.execute(
            "SELECT * FROM tasks WHERE taskID = ?",
            (
                request.form["id"],
            ),
        )
        thistask = cur.fetchall()
        if len(thistask) == 1:
            # Debug: Show what we're about to update
            new_completion_value = 1 if request.form["state"] == "1" else 0
            print(
                f"DEBUG: Updating taskID {request.form['id']} to completion {new_completion_value}"
            )
            # this sql statement was adjusted by chat GPT, i have no clue what im doing with SQL.
            cur = db.execute(
                """
            UPDATE tasks
            SET taskCompletion = ?
            WHERE ownerID = ? AND taskID = ?;
            """,
                (
                    new_completion_value,
                    session["github_id"],
                    request.form["id"],
                ),
            )
            if new_completion_value == 1:
                db.execute("""INSERT INTO transactions (
                             relatedTaskID,
                             transactionCost,
                             transactionType,
                             transactionName
                         )
                         VALUES (
                             ?,
                             ?,
                             2,
                             ?
                         );
""",(request.form["id"],thistask[0]['taskValue'], f"Completed task: {thistask[0]['taskName']}", ))
            elif new_completion_value == 0:
                db.execute("DELETE FROM transactions WHERE relatedTaskID = ?", (request.form["id"],))
            db.commit()

            # Debug: Verify the update worked
            cur = db.execute(
                "SELECT taskCompletion FROM tasks WHERE ownerID = ? and taskID = ?",
                (
                    session["github_id"],
                    request.form["id"],
                ),
            )
            updated_result = cur.fetchall()
            print(
                f"DEBUG: After update, taskCompletion = {updated_result[0]['taskCompletion'] if updated_result else 'NOT FOUND'}"
            )

        elif len(res) == 0:
            state = "eNotFound"
        elif len(res) > 1:
            state = "eTooManyFound"
        # tasks = []
        cur = db.execute(
            "SELECT * FROM tasks WHERE ownerID = ?", (session["github_id"],)
        )
        res = cur.fetchall()
        for task in res:
            print(dict(task))
        # for task in res:
        #     tasks.append(json.dumps(dict(task)))
        # sql by chatGPT again, i hate working with SQL but it made the most sense for this
        # cur = db.execute(
        #     "SELECT COALESCE(SUM(taskValue), 0) AS total_value FROM tasks WHERE ownerID = ? and taskCompletion = 1;",
        #     (session["github_id"],),
        # )
        return generateUpdates(state)
    else:
        return generateUpdates(f"0${state}")


@app.route("/api/addTask", methods=["POST"])
def addTask():
    state = "1$it probably worked idk"
    selector = "ul.tasksList"
    if (
        "dueBy" in request.form
        and "taskValue" in request.form
        and "taskName" in request.form
    ):
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            task_value = int(request.form["taskValue"])
            due_by = (
                -1 if request.form["dueBy"] == "NaN" else int(request.form["dueBy"])
            )
            task_name = request.form["taskName"].strip()

            if not task_name:
                state = "eEmptyTaskName"
                return generateUpdates(f"0${state}")

        except ValueError:
            state = "eInvalidNumber"
            return generateUpdates(f"0${state}")

        db = get_db()
        try:
            cur = db.execute(
                """
INSERT INTO tasks (
                        completionDate,
                        creationDate,
                        dueBy,
                        taskCompletion,
                        taskValue,
                        taskName,
                        ownerID
                    )
                    VALUES (
                        -1,
                        ?,
                        ?,
                        0,
                        ?,
                        ?,
                        ?
                    );
            """,
                (
                    time.time(),
                    due_by,
                    task_value,
                    task_name,
                    session["github_id"],
                ),
            )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}")
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}")

        return generateUpdates(state)

    else:
        return generateUpdates(state)


@app.route("/api/deleteTask", methods=["POST"])
def deleteTask():
    state = "1$it probably worked idk"
    selector = "ul.tasksList"
    if "id" in request.form:
        if not github.authorized:
            return redirect(url_for("github.login"))

        # Validate and convert inputs
        try:
            task_id = int(request.form["id"])

            if not task_id:
                state = "eNoID"
                return generateUpdates(f"0${state}")

        except ValueError:
            state = "eVerror"
            return generateUpdates(f"0${state}")

        db = get_db()
        try:
            # cur = db.execute(
            #     "SELECT * FROM tasks WHERE taskID = ? AND ownerID = ?",
            #     (
            #         request.form["id"],
            #         session["github_id"],
            #     ),
            # )
            # # dumb name, just means store the value properly, into the users coin balance
            # task = cur.fetchone()
            # commitTaskEvasion = task["taskCompletion"] == 1
            cur = db.execute(
                "DELETE FROM tasks WHERE taskID = ?",
                (
                    int(request.form["id"]),
                ),
            )
            # if commitTaskEvasion:
            #     cur = db.execute(
            #         "UPDATE users SET userCoins = userCoins + ? WHERE userID = ?;",
            #         (
            #             task["taskValue"],
            #             session["github_id"],
            #         ),
            #     )
            db.commit()
        except sqlite3.Error:
            state = "eDatabaseError"
            return generateUpdates(f"0${state}")
        return generateUpdates(state)

    else:
        return generateUpdates(state)


@app.route("/api/deleteaccount", methods=["GET"])
def goodbyecruelworld():
    # First check: Referer protection against prank links
    referer = request.headers.get("Referer")
    origin = request.headers.get("Origin")
    allowed_origins = ["https://gt.sometgirl.online"]
    if origin not in allowed_origins and (
        not referer or not any(referer.startswith(o) for o in allowed_origins)
    ):
        return """
<h1>EEK!</h1>
You must have clicked a "prank" link or something! It tried to DELETE YOUR ACCOUNT :sob:<br>
Don't worry, your data is safe :D <br>
If you did request account deletion, you might want to download your data<br>
Once downloaded, you can browse your user data using any SQLite viewer tool like <a href="https://sqliteviewer.app/">SQLiteViewer.app (runs entirely in your browser, your data is never sent anywhere, unaffiliated though) </a>
<h1><a href="/api/getUserData">Click to download your data</a></h1>
<h1><a href="/">Take me to goblintasks</a></h1>
<small><i>you should probably smite the person that sent you this link, they're evil lmao</i></small>
    """

    # Must be authenticated
    if not github.authorized:
        return redirect(url_for("github.login"))

    # Generate secure deletion token
    if "github_id" not in session:
        resp = github.get("/user")
        assert resp.ok
        user_info = resp.json()
        session["github_id"] = user_info["id"]
        session["github_login"] = user_info["login"]

    deletion_token = generate_deletion_token(session["github_id"])

    return f"""
<center>
<h1>Are you sure :3c?</h1>
<i>You're about to delete your account</i><br><br>
<strong>This action cannot be undone!</strong><br><br>
<a href="/api/deleteaccountforreals?token={deletion_token}" 
   onclick="return confirm('Are you ABSOLUTELY sure? This will permanently delete all your tasks and data!')">
   Yes, delete my account permanently
</a><br><br>
<a href="/">No, take me back to safety</a><br><br>
<small><i>This deletion link expires in 5 minutes for security.</i></small>
</center>
"""


@app.route("/api/deleteaccountforreals", methods=["GET"])
def actuallydeleteaccount():
    # Must be authenticated
    if not github.authorized:
        return redirect(url_for("github.login"))

    # Get token from URL
    token = request.args.get("token")
    if not token:
        return (
            """
<center>
<h1>security sillies</h1>
<p>ur token is missing, not ur fault probably, just start it again.</p>
<a href="/api/deleteaccount">go again</a> | 
<a href="/">Go home</a>
</center>
""",
            400,
        )

    # Validate token
    if not validate_deletion_token(token, session["github_id"]):
        return (
            """
<center>
<h1>oops</h1>
<p>the security token is invalid!</p>
<ul style="text-align: left; max-width: 400px;">
<li>it expired (links expire after 5 minutes)</li>
<li>it was tampered with</li>
<li>we dont think you are the person who requested deletion</li>
</ul>
<a href="/api/deleteaccount">Restart process</a> | 
<a href="/">Go home</a>
</center>
""",
            403,
        )

    # Additional confirmation using POST method for the actual deletion
    return f"""
<center>
<h1>FINAL WARNING</h1>
<p><strong>youre about to permenantly delete your account</strong></p>
<p>say your goodbyes to:</p>
<ul style="text-align: left; max-width: 300px;">
<li>tasks</li>
<li>coins</li>
<li>everything else</li>
</ul>
<br>
<form method="POST" action="/api/executeaccountdeletion" onsubmit="return confirm('are you really sure? this is ur last chance, and your data cannot be recovered (we dont store it)')">
    <input type="hidden" name="token" value="{token}">
    <input type="hidden" name="csrf_token" value="{secrets.token_hex(16)}">
    <button type="submit" style="background: red; color: white; padding: 10px 20px; border: none; cursor: pointer;">
        yes i am very sure
    </button>
</form>
<br>
<a href="/">no i wanna stay!</a>
</center>
"""


@app.route("/api/executeaccountdeletion", methods=["POST"])
def executeaccountdeletion():
    if not github.authorized:
        return redirect(url_for("github.login"))
    token = request.form.get("token")
    if not token or not validate_deletion_token(token, session["github_id"]):
        return "oops, try again (security issues)", 403
    try:
        revoke_github_token(blueprint.token["access_token"])
        os.remove(os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            "userdata",
            f"user_{session['github_id']}.sqlite",
        ))
        logout()
        session.clear()

        return """
<center>
<h1>byee :3c</h1>
<p>its all gone, no we cant recover it, dont ask. we never retain your data</p>
</center>
"""

    except Exception as e:
        print(e)
        return f"Deletion failed: {str(e)}", 500

@app.route("/api/getUserData", methods=["GET"])
def getUserData():
    if not github.authorized:
        return redirect(url_for("github.login"))
    try:
        return send_file(os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            os.getenv("dataDir"),
            "userdata",
            f"user_{session['github_id']}.sqlite",
        ))
    except Exception as e:
        print(e)
        return f"Download failed: {str(e)}", 500



if __name__ == "__main__":
    app.run(port=os.getenv("port"), ssl_context=("cert.pem", "key.pem"))
